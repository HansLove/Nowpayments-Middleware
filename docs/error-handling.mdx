# Error Handling

Comprehensive error handling guide for NowPayments middleware.

## Error Types

The middleware provides several error types for different scenarios:

```typescript
import {
  NowPaymentsError,
  NowPaymentsApiError,
  NowPaymentsConfigError,
  NowPaymentsValidationError,
  NowPaymentsNetworkError,
} from '@taloon/nowpayments-middleware';
```

## Callback-Based Error Handling

The middleware provides flexible error handling through callbacks that give you complete control over error responses. You can configure error handlers at three levels with a clear priority system:

1. **Per-middleware `onError` handler** (highest priority)
2. **Global `onError` in configuration** (medium priority)
3. **Legacy `errorHandling` mode** ('next' | 'direct', lowest priority - fallback)

### ErrorHandler Type

```typescript
type ErrorHandler = (
  error: unknown,
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) => void | Promise<void>;
```

### Per-Middleware Error Handler

Handle errors for specific endpoints with custom logic:

```typescript
app.post('/create-payment',
  NowPaymentsMiddleware.createPayment({
    mapRequest: (req) => ({
      price_amount: req.body.amount,
      price_currency: req.body.currency,
      pay_currency: req.body.cryptoCurrency,
    }),
    onError: async (error, req, res, next) => {
      console.error('Payment creation error:', error);

      if (error instanceof NowPaymentsApiError) {
        return res.status(503).json({
          success: false,
          error: 'Payment service temporarily unavailable. Please try again.',
        });
      }

      if (error instanceof NowPaymentsValidationError) {
        return res.status(400).json({
          success: false,
          error: error.message,
        });
      }

      res.status(500).json({
        success: false,
        error: 'Payment creation failed',
      });
    },
  }),
  (req, res) => {
    const payment = res.locals.nowPaymentsResponse;
    res.status(201).json({ success: true, payment });
  }
);
```

### Global Error Handler

Configure a global handler for all middleware operations:

```typescript
NowPaymentsMiddleware.configure({
  apiKey: 'your-api-key',
  onError: async (error, req, res, next) => {
    // Log to monitoring service
    console.error('NowPayments error:', {
      path: req.path,
      method: req.method,
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    if (error instanceof NowPaymentsError) {
      return res.status(error.statusCode || 400).json({
        success: false,
        code: error.code,
        message: 'Payment service error',
      });
    }

    // Pass non-NowPayments errors to Express error handler
    next(error);
  },
});
```

### Priority System Example

Per-middleware handlers override global handlers:

```typescript
// Global handler (applies to all operations)
NowPaymentsMiddleware.configure({
  apiKey: 'your-api-key',
  onError: async (error, req, res, next) => {
    console.log('Global handler');
    res.status(500).json({ error: 'Global error' });
  },
});

// This uses the per-middleware handler (overrides global)
app.post('/payments',
  NowPaymentsMiddleware.createPayment({
    mapRequest: (req) => ({ /* ... */ }),
    onError: async (error, req, res, next) => {
      console.log('Per-middleware handler (takes priority)');
      res.status(500).json({ error: 'Payment-specific error' });
    },
  })
);

// This uses the global handler (no per-middleware override)
app.post('/payouts',
  NowPaymentsMiddleware.createPayout({
    mapRequest: (req) => ({ /* ... */ }),
    // No onError - falls back to global onError
  })
);
```

### Advanced: Conditional Error Passing

You can choose to handle some errors and pass others to Express:

```typescript
NowPaymentsMiddleware.configure({
  apiKey: 'your-api-key',
  onError: async (error, req, res, next) => {
    // Handle NowPayments-specific errors
    if (error instanceof NowPaymentsError) {
      console.error('NowPayments error:', error.code);
      return res.status(error.statusCode || 500).json({
        error: {
          code: error.code,
          message: 'Payment service error',
        },
      });
    }

    // Pass other errors to Express error handling middleware
    next(error);
  },
});

// Express error handler for non-NowPayments errors
app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Express error handler:', error);
  res.status(500).json({ error: 'Internal server error' });
});
```

### Integration with Logging Services

```typescript
import * as Sentry from '@sentry/node';

NowPaymentsMiddleware.configure({
  apiKey: 'your-api-key',
  onError: async (error, req, res, next) => {
    // Report to Sentry
    Sentry.captureException(error, {
      tags: {
        source: 'nowpayments-middleware',
        path: req.path,
      },
    });

    if (error instanceof NowPaymentsError) {
      return res.status(error.statusCode || 500).json({
        error: {
          code: error.code,
          message: process.env.NODE_ENV === 'production'
            ? 'Payment service error'
            : error.message,
        },
      });
    }

    next(error);
  },
});
```

## Basic Error Handling

```typescript
import express from 'express';
import { NowPaymentsError } from '@taloon/nowpayments-middleware';

const app = express();

// Global error handler
app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Application error:', error);
  
  if (error instanceof NowPaymentsError) {
    return res.status(error.statusCode || 400).json({
      success: false,
      error: {
        code: error.code,
        message: error.message,
      },
    });
  }
  
  // Handle other errors
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
    },
  });
});
```

## Error Handling Modes

### Next Mode (Recommended)

Passes errors to Express error handling middleware:

```typescript
NowPaymentsMiddleware.configure({
  apiKey: 'your-api-key',
  errorHandling: 'next', // Default
});

// Errors will be passed to your error middleware
app.use((error, req, res, next) => {
  // Handle NowPayments errors here
});
```

### Direct Mode

Sends error responses directly (not recommended for production):

```typescript
NowPaymentsMiddleware.configure({
  apiKey: 'your-api-key',
  errorHandling: 'direct',
});

// Errors are sent directly as HTTP responses
// No additional error handling needed
```

## Specific Error Handling

### API Errors

```typescript
app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  if (error instanceof NowPaymentsApiError) {
    console.error('NowPayments API error:', {
      message: error.message,
      statusCode: error.statusCode,
      code: error.code,
    });
    
    return res.status(error.statusCode).json({
      error: {
        code: 'PAYMENT_API_ERROR',
        message: 'Payment service is temporarily unavailable',
      },
    });
  }
  
  next(error);
});
```

### Configuration Errors

```typescript
app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  if (error instanceof NowPaymentsConfigError) {
    console.error('Configuration error:', error.message);
    
    return res.status(500).json({
      error: {
        code: 'SERVICE_CONFIGURATION_ERROR',
        message: 'Payment service is not properly configured',
      },
    });
  }
  
  next(error);
});
```

### Validation Errors

```typescript
app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  if (error instanceof NowPaymentsValidationError) {
    console.error('Validation error:', error.message);
    
    return res.status(400).json({
      error: {
        code: 'VALIDATION_ERROR',
        message: error.message,
      },
    });
  }
  
  next(error);
});
```

### Network Errors

```typescript
app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  if (error instanceof NowPaymentsNetworkError) {
    console.error('Network error:', error.message);
    
    return res.status(503).json({
      error: {
        code: 'NETWORK_ERROR',
        message: 'Payment service is temporarily unavailable',
      },
    });
  }
  
  next(error);
});
```

## Complete Error Handler

```typescript
import express from 'express';
import {
  NowPaymentsError,
  NowPaymentsApiError,
  NowPaymentsConfigError,
  NowPaymentsValidationError,
  NowPaymentsNetworkError,
} from '@taloon/nowpayments-middleware';

const errorHandler = (error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  // Log all errors
  console.error('Error occurred:', {
    url: req.url,
    method: req.method,
    error: error.message,
    stack: error.stack,
  });

  // Handle NowPayments specific errors
  if (error instanceof NowPaymentsApiError) {
    return res.status(error.statusCode).json({
      success: false,
      error: {
        code: 'PAYMENT_API_ERROR',
        message: 'Payment service error',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      },
    });
  }

  if (error instanceof NowPaymentsConfigError) {
    return res.status(500).json({
      success: false,
      error: {
        code: 'CONFIGURATION_ERROR',
        message: 'Service configuration error',
      },
    });
  }

  if (error instanceof NowPaymentsValidationError) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: error.message,
      },
    });
  }

  if (error instanceof NowPaymentsNetworkError) {
    return res.status(503).json({
      success: false,
      error: {
        code: 'NETWORK_ERROR',
        message: 'Payment service temporarily unavailable',
      },
    });
  }

  if (error instanceof NowPaymentsError) {
    return res.status(error.statusCode || 400).json({
      success: false,
      error: {
        code: error.code,
        message: error.message,
      },
    });
  }

  // Handle other Express errors
  if (error.status === 404) {
    return res.status(404).json({
      success: false,
      error: {
        code: 'NOT_FOUND',
        message: 'Resource not found',
      },
    });
  }

  // Generic error handler
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
    },
  });
};

// Use the error handler
app.use(errorHandler);
```

## Webhook Error Handling

```typescript
// For webhooks, always respond with 200 to acknowledge receipt
app.post('/webhook/payment',
  NowPaymentsMiddleware.paymentWebhook({
    onFinished: async (payload) => {
      try {
        // Process payment completion
        await processPaymentCompletion(payload);
      } catch (error) {
        console.error('Error processing payment webhook:', error);
        // Don't throw - log and continue
      }
    },
    onFailed: async (payload) => {
      try {
        // Handle payment failure
        await handlePaymentFailure(payload);
      } catch (error) {
        console.error('Error handling payment failure:', error);
        // Don't throw - log and continue
      }
    },
  }),
  // Custom webhook error handler
  (error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
    console.error('Webhook processing error:', error);
    
    // Always acknowledge webhook receipt
    res.status(200).json({
      received: true,
      error: 'Processing failed but webhook acknowledged',
    });
  }
);
```

## Retry Logic

```typescript
import axios from 'axios';

const retryableOperations = async (operation: () => Promise<any>, maxRetries = 3) => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (error instanceof NowPaymentsNetworkError && attempt < maxRetries) {
        console.log(`Attempt ${attempt} failed, retrying...`);
        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        continue;
      }
      throw error;
    }
  }
};

// Usage in your route
app.post('/create-payment', async (req, res, next) => {
  try {
    await retryableOperations(async () => {
      // Your payment creation logic here
    });
  } catch (error) {
    next(error);
  }
});
```

## Development vs Production

```typescript
const isDevelopment = process.env.NODE_ENV === 'development';

app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Error:', error);

  if (error instanceof NowPaymentsError) {
    return res.status(error.statusCode || 400).json({
      success: false,
      error: {
        code: error.code,
        message: error.message,
        // Include stack trace only in development
        ...(isDevelopment && { stack: error.stack }),
      },
    });
  }

  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: isDevelopment ? error.message : 'An unexpected error occurred',
      ...(isDevelopment && { stack: error.stack }),
    },
  });
});
```